# Anatomy of a Block

Before diving into the process of building custom blocks, it's important to understand the structure and components of a block. In this lesson, we'll explore the key parts of a block, how to register a block and the different components of a block, and how to use block attributes and block supports to enhance the block's functionality.

## Block Registration

Block registration involves defining the block's metadata, settings, and behavior and requires two parts:

- Registering the block’s code with WordPress using the PHP register\_block\_type function
- Registering the block in the editor with the JavaScript registerBlockType function.

## register\_block\_type

`register_block_type` accepts two arguments, but the recommended way to use it is to pass the path to the block's directory as an argument.

Below is an example of how to register a block using the `register_block_type` function:

```
/**
 * Registers the block using the metadata loaded from the `block.json` file.
 * Behind the scenes, it registers also all assets so they can be enqueued
 * through the block editor in the corresponding context.
 *
 * @see https://developer.wordpress.org/reference/functions/register_block_type/
 */
function create_block_my_custom_block_block_init() {
	register_block_type( __DIR__ . '/build/my-custom-block' );
}
add_action( 'init', 'create_block_my_custom_block_block_init' );
```

Notice how the block's registration is hooked into the WordPress `init` action.

Registering the block this way will automatically detect and use the `block.json` file to register it. This file contains all the necessary information about the block, including its name, title, description, attributes, and the paths to the scripts and styles that make up its functionality and styling.

```
{
	"$schema": "https://schemas.wp.org/trunk/block.json",
	"apiVersion": 3,
	"name": "create-block/my-custom-block",
	"version": "0.1.0",
	"title": "My Custom Block",
	"category": "widgets",
	"icon": "smiley",
	"description": "Example block scaffolded with Create Block tool.",
	"example": {},
	"supports": {
		"html": false
	},
	"textdomain": "my-custom-block",
	"editorScript": "file:./index.js",
	"editorStyle": "file:./index.css",
	"style": "file:./style-index.css",
	"viewScript": "file:./view.js"
}
```

Let's break down the key properties in this file:

* `$schema`: The URL of the schema that defines the structure of the `block.json` file.
* `apiVersion`: The version of the block API that the block uses.
* `name`: A unique identifier for the block, typically prefixed with your plugin or theme name.
* `version`: The version number of the block.
* `title`: The human-readable name of the block, displayed in the block inserter.
* `category`: The category in which the block will appear in the block inserter (e.g., "common", "formatting", "layout", "widgets", "embed").
* `icon`: The icon to display for the block in the block inserter. This can be a Dashicon or a custom SVG.
* `description`: A brief description of the block's purpose.
* `supports`: An object that defines the features the block supports, such as HTML editing or alignment options.
* `textdomain`: The text domain for the block, used for localization.
* `editorScript`: The path to the JavaScript file that contains the block's editor functionality.
* `editorStyle`: The path to the CSS file that contains the block's editor styles.
* `style`: The path to the CSS file that contains the block's styles.
* `viewScript`: The path to a JavaScript file that can contain additional front-end functionality.

You’ll notice that the `editorScript` is pointing to the `index.js` file in the build directory. This file generated during the build process contains the minified and optimized version of the code in the `src` directory.

## registerBlockType

In the `index.js` file in the `src` directory, you use the `registerBlockType` function from the `@wordpress/blocks` package to register all the features and functionality of the block when the editor loads. At a minimum, `registerBlockType` needs two things:

* The block name
* A JavaScript object containing properties for the edit and save functionality of the block

Below is an example of the `index.js` file generated by `create-block`:

```javascript
/**
 * Registers a new block provided a unique name and an object defining its behavior.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
import { registerBlockType } from '@wordpress/blocks';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * All files containing `style` keyword are bundled together. The code used
 * gets applied both to the front of your site and to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './style.scss';

/**
 * Internal dependencies
 */
import Edit from './edit';
import save from './save';
import metadata from './block.json';

/**
 * Every block starts by registering a new block type definition.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
registerBlockType( metadata.name, {
	/**
	 * @see ./edit.js
	 */
	edit: Edit,

	/**
	 * @see ./save.js
	 */
	save,
} );
```

You will see that this code imports the `style.scss`, the `Edit` component, `save` function and the metadata in `block.json` from their respective files in order to apply the styles and functionality to the block being registered.

This is a feature of modern JavaScript called [module bundling](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). It allows you to separate logical functions and components into separate files. You can then import the code from those files to use it. It also allows you to import code from external libraries, in this case the `@wordpress/blocks` package.

#### The `edit` Component

The `edit` component defines the interface that users interact with when editing the block in the editor.

This component is a JavaScript function that returns a React element, describing how the block should appear and behave.

Here's an example of an `edit` component generated by create-block:

```javascript
/**
 * Retrieves the translation of text.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-i18n/
 */
import { __ } from '@wordpress/i18n';

/**
 * React hook that is used to mark the block wrapper element.
 * It provides all the necessary props like the class name.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-block-editor/#useblockprops
 */
import { useBlockProps } from '@wordpress/block-editor';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * Those files can contain any CSS code that gets applied to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './editor.scss';

/**
 * The edit function describes the structure of your block in the context of the
 * editor. This represents what the editor will render when the block is used.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#edit
 *
 * @return {Element} Element to render.
 */
export default function Edit() {
	return (
		<p { ...useBlockProps() }>
			{ __(
				'My Custom Block – hello from the editor!',
				'my-custom-block'
			) }
		</p>
	);
}
```

#### The `save` Function

The `save` function is responsible for defining the block's output on the site's front end. This function is also a JavaScript function that returns a React element, describing how the block should be rendered.

Here's an example of a `save` function generated by create-block:

```javascript
/**
 * React hook that is used to mark the block wrapper element.
 * It provides all the necessary props like the class name.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-block-editor/#useblockprops
 */
import { useBlockProps } from '@wordpress/block-editor';

/**
 * The save function defines the way in which the different attributes should
 * be combined into the final markup, which is then serialized by the block
 * editor into `post_content`.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#save
 *
 * @return {Element} Element to render.
 */
export default function save() {
	return (
		<p { ...useBlockProps.save() }>
			{ 'My Custom Block – hello from the saved content!' }
		</p>
	);
}
```

#### useBlockProps

You will notice that both the `Edit` component and `save` function use `useBlockProps`. `useBlockProps` is a React hook that allows developers to manage and apply properties to the root element of a block, ensuring consistency between the editor and the front end.

Developers can use `useBlockProps` to add custom attributes (e.g., `className`, inline styles) to the root element of a block. It also consolidates attributes like alignment classes and other editor-specific properties into the block’s wrapper element, making it easier to manage.

#### Block Attributes

Attributes define the data that a block stores and manages. Each attribute has a name, a type, and, optionally, a default value. Attributes can be defined in the `attributes` property of the `block.json` file.

Here are some common attribute types:

* `string`: A text string.
* `number`: A number.
* `boolean`: A true/false value.
* `array`: An array of values.
* `object`: An object containing key-value pairs.

Here's an example of how to define attributes for a block:

```
attributes: {
  content: {
    type: 'string',
    default: 'Hello World!',
  },
  alignment: {
    type: 'string',
    default: 'left',
  },
  imageUrl: {
    type: 'string',
  },
},
```

In this example, we're defining three attributes: `content`, `alignment`, and `imageUrl`. The `content` attribute is a string with a default value of "Hello World\!", the `alignment` attribute is a string with a default value of "left", and the `imageUrl` attribute is a string with no default value.

### Accessing the block’s attributes

Attributes are passed to a block’s Edit component or save function via a `props` object. Both the Edit component and the save function are set up to always accept this props object containing all the properties of the block.  
Developers can then access the content of the attribute by accessing the `attributes` property on the `props` object.

```javascript
export default function Edit( props ) {
	const blockContent = props.attributes.content;
	return (
		<p { ...useBlockProps() }>
			{ __(
				blockContent,
				'my-custom-block'
			) }
		</p>
	);
}
```

Modern JavaScript also supports [object destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), which allows you to extract specific properties from an object and assign them to variables. This can make your code more concise and easier to read.

To start, you can destructure the `attributes` property from the `props` object like this:

```javascript
export default function Edit( { attributes } ) {
    const content = attributes.content;
    return (
        <p { ...useBlockProps() }>
            { __(
                content,
                'my-custom-block'
            ) }
        </p>
    );
}
```

You can also destructure the `content` property directly from the `attributes` object like this:

```javascript
export default function Edit( { attributes } ) {
    const { content } = attributes;
    return (
        <p { ...useBlockProps() }>
            { __(
                content,
                'my-custom-block'
            ) }
        </p>
    );
}
```

#### Block Supports

The `supports` property allows you to define the common features that a block supports. This can include things like HTML editing, alignment options, custom styles, and more.

Supports are defined as an object containing key-value pairs, where the key is the name of the feature and the value is a boolean or an object containing additional settings.

Here are some common block supports:

* `html`: Whether the block supports HTML editing.
* `align`: Whether the block supports alignment options (e.g., "left", "center", "right", "wide", "full").
* `className`: Whether the block should have a CSS class name automatically generated.
* `customClassName`: Whether the user can add a custom CSS class name to the block.
* `multiple`: Whether multiple instances of the block can be inserted into a post.

Here's an example of how to define block supports in `block.json`:

```
supports: {
  html: false,
  align: true
},
```

In this example, we're disabling HTML editing and enabling alignment options. This will add the alignment toolbar to the block in the editor, allowing users to choose from different alignment options.

Now that you have a better understanding of the anatomy of a block, you're ready to start building your own custom blocks. In the next lesson, we'll explore the block development workflow and how to set up your local environment for block development.  